# Verification, Validation, and Test

SW 개발이 완료된 이후 확인하는 과정. 

### Verification

개발 각 단계별로, 제대로 개발이 진행되고 있는지 확인하는 단계 (중간 점검)

### Validation

최종적으로 만들어진 결과물이 고객의 요구사항을 만족 시키는지 확인 (최종 점검)

### Review

목적에 따라 제대로 목적을 달성했는지 산출물들을 확인 하는 방법 (실행X) 

Ex. 중간 산출물, 코드

### Testing

특정한 요구사항을 만족하는지 ***실제 실행을 통해서*** 확인, 결함을 찾아 가는 과정 (실행O)

## 테스트 케이스

테스트를 실행 할 때는 테스트 계획을 세우고, 그에 맞춰 실행

뭘 테스트 할 지 내용을 정한 것이 테스트 케이스.

어떤 입력을 줬을 때 어떤 결과가 나올지 미리 예상을 해서 예상한 결과가 나오면 통과, 아니면 실패. 시나리오

- 테스트 케이스 명(ID, 카테고리 포함)
- 목적(feature)
- 사전조건(pre-condition)
- 테스트 데이터
- 테스트 절차(test procedure, test script)
- 예상결과(expected output)
- 테스트 환경(HW사양 SW tool 포함)
- 결과 (Pass/Fail)
- 테스트 소요시간/우선순위/비고

⇒ 이와 같은 테스트 케이스는 요구사항이나 설계 문서를 기반으로 만들어질 수 있음

fail (결함) 발생 시 수정 후 재 테스트

### Quality Attribute and Test

품질 속성과 테스트와의 관계.

기능 테스트 → 기능 요구사항을 확인

비기능 테스트 → 비기능과 관련된 요구사항을 확인

## Error, Fault, Failure

### Error

실수. 잘못하여 만들어낸 것

### Fault

에러의 표현 방법. bug, defect

fault는 failure를 유발할 수도, 하지 않을 수도 있음

- software fault: physical 하지 않은 fault (code 상의 문제)
- hardware fault: 영구적 결함, 간헐적 결함

### Failure

fault로 인한 실패. System crash

 

## Testing and Debugging

### Testing

결함을 찾는 활동들

### Debugging

결함이 뭔지 원인을 찾아 코드를 수정한 후 그 결함이 해결 되었는지 확인 하는 과정.

### Confirmation testing

결함을 해결하기 위해 수정한 코드가 전체 프로그램에 영향이 없는지 확인

### Tester

테스트를 수행

### Programmer

테스트 결과에 따라 디버깅을 수행. unit test의 경우 programmer가 직접 testing

# Test Processes

## V-Model


단계별 test 표준

## 단위 테스트

개발자가 자신이 개발한 각 모듈을 테스팅하며 직접 결함을 찾는 일

low-level design 단계의 설계서 상에 정의된 내용을 이행.

결함 발견될 때마다 수정이 용이함.

Ex. White-box 테스트

## 통합 테스트

단위 테스트를 완료한 SW에 대해 진행

SW/ HW 사이의 인터페이스 및 상호 연동하는 동작을 테스트

개발자 이외의 제 3자 테스터에 의한 테스트 필요

## 시스템 테스트

단위 및 통합 테스트가 완료된 후 시스템 테스트

분석 단계의 요구사항에 따라 시스템이 개발 되었는지 검사

기능 테스트와 비기능 테스트

## 인수 테스트

완성된 시스템이 얼마나 사용자의 요구사항을 만족 하였는지 테스트

Requirement 단계로부터 나오는 정보를 이용하여 테스트 데이터 생성

- User acceptance test
- Operational test
- Contact and regulation test
- AlphaTest: 개발환경에서 테스트
- Beta, field test: 사용자 환경에서 테스트

## 주요 테스트 활동

### Test Identification 테스트 대상 정의

도메인 특성, 개발 패러다임,테스트 단계에 따른 테스트가 집중 되어야 할 테스트 항목을 명확히 파악.

### Test data selection 테스트 케이스 선정

도메인 특성 , 개발 패러다임, 테스트 단계에 맞춘, 즉 파악된 테스트 항목이 효과적으로 테스트 될 수 있도록 하는 테스트 데이터를 선정.

---

# Static Test

**테스트의 원칙 1: 프로그램에 숨어있는 버그들을 찾아내는 것**

테스팅: 결함이 존재하는 것을 보여준다.

테스트 후 결함이 발견되지 않았더라도 발견되지 않은 결함이 숨어있을 수 있음.

**테스트의 원칙 2: 완벽한 테스트는 불가능하다.**

테스트는 100% 완벽한 테스트가 불가능하기 때문에 프로그램에 결함이 없는 것을 보여주기 위함이 아닌 결함을 찾기 위함이다.

**테스트의 원칙 3: 새로운 결함을 찾아내려면 목적에 맞는 새로운 테스트를 해야한다.**

테스트를 통해 결함을 찾아냈더라도, 숨어있는 결함을 찾기 위해선 또 다시 테스트를 수행해야 한다.

기능 테스트는 성능과 같은 비기능 적 요소의 결함을 찾아낼 수 없다.

**테스트의 원칙 4: 오류가 없다고 해서 사용자의 요구사항을 만족하는 것은 아니다.**

**테스트의 원칙 5: 상황에 따라 다르게 테스트를 해야 한다. 서로 다른 SW들은 그에 맞는 테스트를 수행해야 한다.**

테스트의 원칙 6: 결함이 특정한 부분에 집중되어 있을 때, 그 부분만 집중적으로 테스트 하는 것이 좋다.

**테스트의 원칙 7: 초기에 테스트를 해야 한다. 요구사항이나 설계에서의 결함을 찾아내기 위해 리뷰를 확인한다.**

## Test Maturity Level

TMM: 조직의 테스트 수준을 측정하는 방법. 테스팅 능력의 수준을 5단계로 구분함.

### 1단계: Performed

디버깅을 테스트로 인식. '작동하는 것'을 보여줄 뿐, 품질 보증과는 무관

### 2단계: Managed

디버깅과  테스트를 구분. 기능 중심의 테스트. 프로그램이 제대로 동작하는지 확인. 개발자가 테스트.

### 3단계: Defined

표준 테스트 프로세스가 정의 되는 단계. V-model의 체계를 갖추고 Verification과 Validation 수행

개발조직과 테스트 조직이 분리. 독립적인 테스트 전문가 그룹 구성.

### 4단계: Quantitatively Managed

전체적인 SW의 품질을 평가하는 단계. Test Architect의 등장.

### 5단계: Optimizing

개선 활동 추진. 결함 예방과 품질 제어가 수행됨. 

## Test Methods

### Non execution-based test (static test)

SW를 실행하지 않고 test. 사람 또는 tool이 함. 요구사항 문서, 설계 문서, code를 test

### Execution-based test (dynamic test)

동작하는 SW를 test. 

## Software design and implementation

구현 단계에서의 결과물을 어떻게 검증하는가?

### Software design

요구사항에 명시된 내용을 추상화된 sw 구조로 나타내는 것

### Implementation

추상화된 구조를 실제 실행 가능한 프로그램으로 만들어내는 것

## Software Design Principles

소프트웨어 설계시 결함을 방지하기 위해 지켜야 할 원칙들

### Software architectural design

요구사항에 작성된 내용을 sw로 구현할 수 있도록 추상화 하여 표기한 것 Ex. UML

추상화 시킨 내용들이 요구사항을 잘 반영하고 있는지 요구사항에 기반하여 확인 

설계 내용을 정적, 동적 관점에서 확인 가능

Design guidelines(설계와 관련된 표준)을 지켜 수행했는가

같이 동작하는 하드웨어와 서로 호환이 가능한지 등을 검증

- SW 아키텍처 설계도 작성 시 고려사항

 - 검증 가능성 (실행X)

 - 구조 변경 가능

 - SW에 대한 적합성

 - 단위 SW로의 설계/ 구현 가능성

 - SW 통합 테스트를 위한 SW아키텍처의 테스트 용이성 (실제로 실행)

 - 유지 보수성

- 과도하게 복잡한 설계로 인한 오류를 방지하기 위해 지켜야 할 설계 속성

 - 모듈화

 - 캡슐화

 - 단순화

- 이를 위해 필요한 아키텍쳐 설계 원칙


응집력: 관련 있는 것들끼리 묶어 모듈화. 하나의 모듈은 단일 기능만 수행하도록.

결합력: SW 모듈 사이의 연결성. 모듈 간 통신으로 인한 결함을 최소화하도록.

# Static Analysis (Static Test)

SW 구현 후 검증 방식: Review나 Static Analysis(정적 분석)

## Types of Review

- 비공식적 리뷰 **(Informal review)** – 공식적인 절차가 없음
– 이인일조(Pair) 프로그래밍에의한 리뷰, 상사가 설계와 코드 리뷰
– 선택적으로 문서화 할 수 있음
– 리뷰 하는 사람에 따라 성과가 좌우
– 목적: 저렴한 방법으로 성과 달성
- 기술적 리뷰 **(Technical review)**

    – 리뷰절차:(계획(참가인원서정,역할할당,EntryExit기준정의), Kick-off(문서배포,리뷰목표및절치,
    문서 설명< 시작 기준 점검), 개별준비( 참석자 별로 사전 리뷰 활동), 리뷰 미팅(토의 및 결과 문서화),
    재작업, 후속처리(, 발견된 결함이 조치되었는지 확인, 종료기준 점검)

    – 목적:기술적문제해결,토론,의사결정,대안평가,결함발견,명세서또는표준과의적합성검토

- 워크스루**(Walkthrough)**

    – 작성자에 의한 진행 및 제어

    – 목적: 학습, 시스템에 대한 이해 향상, 결함 발견

- **Inspections**

    – 작성자가 아닌 훈련된 리더(moderator)에 의한 진행 및 제어

    – 공식적인 리뷰 프로세스를 따르며, 검토자와 별도로 테스터의 역할이있음. 테스터는 어떻게 테스트할 것인가의 관점을 가지고 인스펙션 참여함.

    – 목적: 결함 발견

## 정적 분석 (Static Analysis)

주로 도구가 수행.

- 특징
– 설계/코딩 작성 표준 가이드라인 위반 검사  SW 설계/코딩 가이드라인

    – 설계/코드 메트릭 측정
    – 런-타임 오류 가능성 검사

- 장점

    – 자동화 가능
    • 설계 검증을 위한 품질 측정 도구: SimulinkQAC
    • 코드 검증을 위한 품질 측정 도구: Code Inspector, Polyspace, Code Sonar, LDRA

    – 호스트 PC에서 적용 가능

리뷰**,** 정적 분석**,** 동적 테스트는 각기 대체될 수 없다**,** 즉 서로 보완적이다**.**


