## 비용 추정

합리적인 가격을 제시하는 게 중요하나, 소프트웨어 프로젝트에서는 프로젝트가 끝나야만 정확한 비용을 알 수 있다.

## 추정 방법

들어가야 할 노력 비용 등으로 추정. 두 가지 비용 산정 방법이 있음

### 경험 기반 기법 (Experience-based techniques)

과거 프로젝트 경험과 도메인에 대한 지식 기반으로 비용을 산정.

### 알고리즘 기반 기법 (Algorithmic cost modeling)

프로젝트의 규모, 특성을 기반으로 비용을 수학적으로 사용하는 방법.

## 경험 기반 기법 (Experience-based techniques)

- 과거 프로젝트의 경험과 진행할 프로젝트의 차이를 분석해 필요한 노력의 규모를 판단
- 산출물(deliverable) 파악, 개발할 소프트웨어와 개발한 소프트웨어 간의 차이를 분석
- 차이에 대해 개별적으로 분석해 문서화, 모두 합해 총 비용을 추정
- 기술은 계속해서 변하므로 이전의 방법들이 새로운 프로젝트에 꼭 맞다고 할 수 x, 낙관적으로 비용 추정을 할 위험 o
- 예산에 제품을 맞추는 경우도 생길 수 o

## 알고리즘 기반 기법 (Algorithmic cost modeling)

- 비용에 영향을 미치는 제품, 프로세스 속성들을 변수로 하여 수학적으로 값을 측정하는 방법

<img width="1042" alt="스크린샷 2020-09-12 오후 4 46 31" src="https://user-images.githubusercontent.com/45806836/92990432-85703e00-f517-11ea-8ac5-8406321d8916.png">  

A: 조직과 관련된 상수

B: 프로젝트 규모와 관련된 값

M: 제품, 프로세스 등 속성을 반영하는 값

Size: 코드 크기 

- 대부분의 모델들이 이 식을 사용, 차이는 A, B, M
- 수식에 사용되는 값들이 프로젝트 관리자에 의해 측정되므로 객관적이진 않다.

### 측정의 정확성

- 최종적인 소프트웨어의 크기는 개발이 끝나서야 알 수 있음
- 최종적인 크기에 영향을 미치는 요인은 COTS(상업적으로 판매하는 소프트웨어-구매한 모듈들을 사용할 수 있음)와 component들, 사용한 언어
- 개발이 진행됨에 따라 size는 정확해 짐
- 수식에 사용된 값들은 측정하는 사람에 따라 달라질 수 있어 주관적임

    <img width="1026" alt="스크린샷 2020-09-12 오후 4 46 45" src="https://user-images.githubusercontent.com/45806836/92990438-8c974c00-f517-11ea-87b2-1715eaaa82da.png">  
    
### Size(프로젝트 규모)의 측정 요소

### LOC (Lines of code): 개발자 입장의 계산

- 시스템의 크기와 문서의 양 사이 선형적으로 관계가 있다고 가정 (시스템의 크기가 커질수록 작성되는 코드의 양이 많아진다.)
- 언어에 따라 달라질 수 있으며 동일 코드를 고급 언어로 구현하는 것이 lower-level언어로 구현하는 것보다 적은 양의 코드를 짤 수 있다.

→ LOC로만 판단한다면 저급 언어로 작성한 코드가 생산성이 더 높다고 판단 됨

- 프로그래머가 하루에 얼마만큼 일을 할 수 있는지는 하루에 작성된 코드의 양을 통해 판단

→ 간결한 코드보다 코드를 길게 작성하는 개발자가 생산성이 높다고 판단 될 수 있음

<img width="1057" alt="스크린샷 2020-09-12 오후 4 47 42" src="https://user-images.githubusercontent.com/45806836/92990454-afc1fb80-f517-11ea-8f2a-3b53835945be.png">  

### Function-points: 고객 입장의 계산

- 사용자가 어떤 기능을 요구하는 지에 초점, 기능의 양을 예상해 소프트웨어 크기를 추정

→ 기능: 외부 입출력, 사용자 인터페이스, 외부 인터페이스, 사용되는 파일들

- 기능들 하나하나에 가중치 값을 둬서 소프트웨어의 크기를 계산

**UFP (미보정 기능 점수)**

<img width="952" alt="스크린샷 2020-09-12 오후 4 48 38" src="https://user-images.githubusercontent.com/45806836/92990479-d122e780-f517-11ea-9bc2-86e035a61780.png">  

but, 요구사항 만으로 소프트웨어의 크기를 계산하는 것은 기술적인 부분을 고려하지 않은 방법. 소프트웨어를 만들 때는 여러 가지 알고리즘 요소들에 의해 복잡도가 달라질 수 있기 때문에 프로젝트 특성에 따라 기술적인 특성을 함께 반영 해야함.

**기술적 복잡도에 영향을 미치는 14가지 항목**

<img width="1108" alt="스크린샷 2020-09-12 오후 4 49 12" src="https://user-images.githubusercontent.com/45806836/92990492-e5ff7b00-f517-11ea-9be0-b2911b2b27ae.png">  

⇒ 최종적인 기능 점수 : 미보정 기능 점수(UFP) x 기능 복잡도 점수 (TCF)

### Algorithmic cost modelling: The COCOMO model

프로젝트 규모에 따라 프로젝트 비용을 계산하는 방법

- COCOMO 2 모델: 4가지 하위 모델로 구성

**Application composition model**. 소프트웨어가 기존에 있는 부품들로 구성될 때 사용

**Early design model.** 요구사항을 사용할 순 있으나 설계를 시작하지 않은 경우

**Reuse model.** 재사용 가능한 요소들이 있을 경우 통합하려는 노력을 계산

**Post-architecture model.** 시스템 구조가 설계 됐고, 자세한 정보가 있을 때

- COCOMO 81 모델: 3가지 개발 모드로 나눌 수 있음

**개발 노력 측정** 

1KDSI = 1000 line

**simple mode** (small, straight forward) 

**moderate mode** (medium size) Ex. 오피스 프로그램

**embedded mode** (complex) Ex. 항공기 프로그램
<img width="1038" alt="스크린샷 2020-09-12 오후 4 49 55" src="https://user-images.githubusercontent.com/45806836/92990506-00395900-f518-11ea-903c-d0fa3803bb81.png">  
